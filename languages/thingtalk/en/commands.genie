// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>

import { Ast, Type } from 'thingtalk';

import * as C from '../ast_manip';

// import thingpedia info
import _tpLoader from '../load-thingpedia';

forward_get_do_command : Ast.ChainExpression = {
    ( ('get' | 'take' | 'retrieve')  table:if_filtered_table ('and then' | 'then') action:thingpedia_action
    | table:complete_get_command ('and then' | 'then' | ',') action:thingpedia_action
    | 'after' ('you get' | 'taking' | 'getting' | 'retrieving') table:with_filtered_table action:thingpedia_action
    | ('get' | 'take' | 'retrieve') table:with_filtered_table ('and then' | 'then') action:thingpedia_action
    ) if !complete => new Ast.ChainExpression(null, [table, action], C.resolveChain(table.schema!, action.schema!));

    // use X to do Y would be good sometimes but it gets confusing quickly
    //['${(get|use)} ${with_filtered_table} to ${thingpedia_action}', checkIfIncomplete(simpleCombine((table, action) => new Ast.Command(null, table, [action])))]
}

complete_forward_get_do_command : Ast.ExpressionStatement = {
    cmd:forward_get_do_command if complete => new Ast.ExpressionStatement(null, cmd);

    !turking command:complete_forward_get_do_command ('with the same' | 'with identical' | 'using the same') joinArg:out_param_Any
        => C.addSameNameParameterPassing(command, joinArg);
}

backward_get_do_command : Ast.ChainExpression = {
    action:thingpedia_action 'after' ('getting' | 'taking' | 'you get' | 'you retrieve') table:with_filtered_table if !complete
        => new Ast.ChainExpression(null, [table, action], C.resolveChain(table.schema!, action.schema!));
}

complete_get_do_command : Ast.ExpressionStatement = {
    complete_forward_get_do_command;
    !turking cmd:backward_get_do_command if complete => new Ast.ExpressionStatement(null, cmd);
    cmd:action_replace_param_with_table if complete => new Ast.ExpressionStatement(null, cmd);
}

forward_when_do_rule : Ast.ChainExpression = {
    // pp from when to do (optional)
    stream:stream action:thingpedia_action ('' | '.') => new Ast.ChainExpression(null, [stream, action], C.resolveChain(stream.schema!, action.schema!));

    // pp from when to do (required)
    // this is because "monitor X and then Y" makes sense only if X flows into Y
    ('monitor' | 'watch') table:with_filtered_table ('and then' | 'then') action:thingpedia_action ('' | '.') if !complete => {
        if (!table.schema!.is_monitorable)
            return null;
        return new Ast.ChainExpression(null, [new Ast.MonitorExpression(null, table, null, table.schema), action],
            C.resolveChain(table.schema!, action.schema!));
    };
    !turking ('monitor' | 'watch') proj:projection_Any ('and then' | 'then') action:thingpedia_action ('' | '.') if !complete => {
        if (!proj.schema!.is_monitorable)
            return null;
        const stream = C.tableToStream(proj);
        if (!stream)
            return null;
        return new Ast.ChainExpression(null, [stream, action], C.resolveChain(stream.schema!, action.schema!));
    };

    'check for new' table:complete_table ('and then' | 'then') action:thingpedia_action ('' | '.') if !complete => {
        if (!table.schema!.is_monitorable)
            return null;
        return new Ast.ChainExpression(null, [new Ast.MonitorExpression(null, table, null, table.schema), action],
            C.resolveChain(table.schema!, action.schema!));
    };
}

complete_forward_when_do_rule : Ast.ExpressionStatement = {
    cmd:forward_when_do_rule if complete => new Ast.ExpressionStatement(null, cmd);

    !turking rule:complete_forward_when_do_rule ('with the same' | 'with identical' | 'using the same') joinArg:out_param_Any
        => C.addSameNameParameterPassing(rule, joinArg);
}

backward_when_do_rule : Ast.ChainExpression = {
    action:thingpedia_action stream:stream ('' | '.')
        => new Ast.ChainExpression(null, [stream, action], C.resolveChain(stream.schema!, action.schema!));

    action:thingpedia_action 'after checking for new' table:complete_table with { is_monitorable = true } ('' | '.') if !complete => {
        if (!table.schema!.is_monitorable)
            return null;
        return new Ast.ChainExpression(null, [new Ast.MonitorExpression(null, table, null, table.schema), action],
            C.resolveChain(table.schema!, action.schema!));
    };
}
complete_when_do_rule : Ast.ExpressionStatement = {
    complete_forward_when_do_rule;
    cmd:backward_when_do_rule if complete => new Ast.ExpressionStatement(null, cmd);

    !turking ('auto' | 'automatically' | 'continuously') stmt:action_replace_param_with_stream if complete => new Ast.ExpressionStatement(null, stmt);
    ?turking 'automatically' stmt:action_replace_param_with_stream if complete => new Ast.ExpressionStatement(null, stmt);
}

when_get_stream : Ast.ChainExpression = {
    // pp from when to get (optional)
    stream:stream table:thingpedia_get_command => C.checkNotSelfJoinStream(new Ast.ChainExpression(null, [stream, table], table.schema));
    ( stream:stream imperative_verb_for_search table:thingpedia_query
    | stream:stream generic_verb_for_search table:thingpedia_query
    ) => C.checkNotSelfJoinStream(new Ast.ChainExpression(null, [stream, table], table.schema));
    ( stream:stream imperative_verb_for_search ('' | 'what is') proj:projection_Any
    | stream:stream generic_verb_for_search ('' | 'what is') proj:projection_Any
    ) => {
        if (proj instanceof Ast.ProjectionExpression) {
            if (!_tpLoader.flags.projection)
                return null;
            if (proj.args[0] === 'picture_url')
                return null;
            let outParams = Object.keys(proj.expression.schema!.out);
            if (outParams.length === 1)
                return null;
        }
        return C.checkNotSelfJoinStream(new Ast.ChainExpression(null, [stream, proj], proj.schema));
    };

    table:thingpedia_get_command stream:stream => C.checkNotSelfJoinStream(new Ast.ChainExpression(null, [stream, table], table.schema));
    ( imperative_verb_for_search table:thingpedia_query stream:stream
    | generic_verb_for_search table:thingpedia_query stream:stream
    | generic_preamble_for_answer table:thingpedia_query stream:stream
    ) => C.checkNotSelfJoinStream(new Ast.ChainExpression(null, [stream, table], table.schema));

    ( imperative_verb_for_search proj:projection_Any stream:stream
    | generic_verb_for_search proj:projection_Any stream:stream
    | generic_preamble_for_answer proj:projection_Any stream:stream
    ) => {
        if (proj instanceof Ast.ProjectionExpression) {
            if (!_tpLoader.flags.projection)
                return null;
            if (proj.args[0] === 'picture_url')
                return null;
            let outParams = Object.keys(proj.expression.schema!.out);
            if (outParams.length === 1)
                return null;
        }
        return C.checkNotSelfJoinStream(new Ast.ChainExpression(null, [stream, proj], proj.schema));
    };
}
complete_when_get_stream : Ast.ExpressionStatement = {
    stream:when_get_stream if complete => new Ast.ExpressionStatement(null, stream);
}

when_get_do_rule : Ast.ExpressionStatement = {
    stream:stream command:complete_get_do_command => C.combineStreamCommand(stream, command.expression);
    command:complete_get_do_command stream:stream => C.combineStreamCommand(stream, command.expression);
}

timer_rule : Ast.ExpressionStatement = {
    // timer => get => notify
    (
          timer:timer table:complete_get_command
        | timer:timer generic_verb_for_search table:complete_table
        | generic_verb_for_search table:complete_table timer:timer
        | timer:timer ('tell me' | 'give me' | 'show me' | 'present' | 'retrieve' | 'pull up') table:complete_table
        | ('tell me' | 'give me' | 'show me' | 'present' | 'retrieve' | 'pull up') table:complete_table timer:timer
    ) => new Ast.ExpressionStatement(null, new Ast.ChainExpression(null, [timer, table], table.schema));
    // timer => do
    (
          timer:timer action:thingpedia_action
        | generic_preamble_for_action action:thingpedia_action timer:timer
    ) if complete => new Ast.ExpressionStatement(null, new Ast.ChainExpression(null, [timer, action], action.schema!));
    // timer => get => do
    !primonly (
          timer:timer command:complete_get_do_command
        | command:complete_get_do_command timer:timer
    ) => new Ast.ExpressionStatement(null, new Ast.ChainExpression(null, ([timer] as Ast.Expression[]).concat(command.expression.expressions), command.expression.schema));
}

generic_preamble_for_answer : string = {
    'i am looking for';
    'i would like';
    'i want';
    'i need';
}
generic_preamble_for_action : string = {
    'i am looking to';
    'i would like to';
    'i want to';
    'i need to';
    'please';
}
generic_verb_for_search : string = {
    'search for';
    'search';
    'find';
    'get';
    'retrieve';
}
imperative_verb_for_search : string = {
    'show me';
    'tell me';
    'give me';
    'find me';
}

generic_search_preamble : string = {
    'search';
    'find';
    'get';
    'show me';
    'give me';
    'find me';
    'i want';
    'i need';
    'i am looking for';
    'i am looking for a particular';
    'i am looking for a certain';
    'i would like';
    'i need';
    'i need some information about';
    'i would like information about';
    'i would like to hear about';
}
generic_lookup_preamble : string = {
    'show me';
    'tell me';
    'give me';
    'find me';
    'search';
    'find';
    'i want to know';
    'i need to know';
    'i am looking for';
    'i would like to know';
    'i would like';
    'i need';
}

generic_article : string = {
    'a';
    'an';
    'the';
    'some';
    'any';
    'all';
    'all the';
    'every';
    'a list of';
    'a list of all';
    'the list of';
    'the list of all';
}

search_command : Ast.ExpressionStatement = {
    (
          table:complete_get_command
        | 'get' generic_article table:with_filtered_table
        | generic_preamble_for_answer generic_article table:with_filtered_table
        | generic_verb_for_search generic_article table:with_filtered_table
        | generic_preamble_for_action generic_verb_for_search generic_article table:with_filtered_table
    ) => new Ast.ExpressionStatement(null, table);
    ( 'please' | '') ('list' | 'enumerate') table:with_filtered_table => {
        if (!table.schema!.is_list)
            return null;
        return new Ast.ExpressionStatement(null, table);
    };

    // now => get join get => notify
    ( generic_preamble_for_answer generic_article table:with_filtered_table
    | generic_verb_for_search generic_article table:with_filtered_table
    | generic_preamble_for_action generic_verb_for_search generic_article table:with_filtered_table
    ) => new Ast.ExpressionStatement(null, table);

    // now => get => notify (argmin, argmax)
    ( generic_preamble_for_answer 'the' table:with_arg_min_max_table
    | generic_verb_for_search 'the' table:with_arg_min_max_table
    ) => new Ast.ExpressionStatement(null, table);

    // now => get => say(...)
    (
          generic_lookup_preamble proj:projection_Any [weight=0.45]
        | ('show me' | 'tell me') 'what is' proj:projection_Any [weight=0.45]
        | generic_lookup_preamble proj:pair_projection [weight=0.1]
    ) => C.sayProjection(proj);

    (
          generic_lookup_preamble proj:command_projection_table
        | ('show me' | 'tell me') 'what is the' proj:command_projection_table
    ) => C.sayProjection(proj);
}

complete_question : Ast.ExpressionStatement = {
    (
          ('what' | 'which') table:verb_filtered_table '?'
        | ('what' | 'which') table:one_be_filter_table '?'
        | ('what' | 'which') table:one_have_filter_table '?'
        | ('what' | 'which') table:one_verb_filter_table '?'
        | ('what' | 'which') table:two_be_filter_table '?'
        | ('what' | 'which') table:two_have_filter_table '?'
        | ('what' | 'which') table:two_verb_filter_table '?'
        | ('what' | 'which') ('are' | 'is') ('the' | '') table:with_filtered_table '?'
        | ('what' | 'which') ('are' | 'is') ('the' | '') table:one_with_filter_table '?'
        | ('what' | 'which') ('are' | 'is') ('the' | '') table:one_which_filter_table '?'
        | ('what' | 'which') ('are' | 'is') ('the' | '') table:one_clean_filter_table '?'
        | ('what' | 'which') ('are' | 'is') ('the' | '') table:two_with_filter_table '?'
        | ('what' | 'which') ('are' | 'is') ('the' | '') table:two_which_filter_table '?'
        | ('what' | 'which') ('are' | 'is') ('the' | '') table:two_clean_filter_table '?'
    ) => new Ast.ExpressionStatement(null, table);


    (

          ('is' | 'are') 'there' ('any' | '') table:with_filtered_table '?'
        | ('is' | 'are') 'there' ('any' | '') table:one_with_filter_table '?'
        | ('is' | 'are') 'there' ('any' | '') table:one_which_filter_table '?'
        | ('is' | 'are') 'there' ('any' | '') table:one_clean_filter_table '?'
        | ('is' | 'are') 'there' ('any' | '') table:two_with_filter_table '?'
        | ('is' | 'are') 'there' ('any' | '') table:two_which_filter_table '?'
        | ('is' | 'are') 'there' ('any' | '') table:two_clean_filter_table '?'
    ) => new Ast.ExpressionStatement(null, table);

    // now => get join get => notify
    (
          ('what' | 'which') ('are' | 'is') ('the' | '') table:with_filtered_table_join
        | ('what' | 'which') table:have_filtered_table_join
    ) => new Ast.ExpressionStatement(null, table);

    // now => get => notify (argmin, argmax)
    (
          ('what' | 'which') 'is the' table:with_arg_min_max_table '?'
        | ('which' | 'what') table:have_arg_min_max_table '?'
    ) => new Ast.ExpressionStatement(null, table);

    // now => get => notify (who questions)
    !turking (
          ('who' | 'which person' | 'which individual') table:who_verb_filtered_table '?'
        | ('who' | 'which person' | 'which individual') table:who_one_be_filter_table '?'
        | ('who' | 'which person' | 'which individual') table:who_one_have_filter_table '?'
        | ('who' | 'which person' | 'which individual') table:who_one_verb_filter_table '?'
        | ('who' | 'which person' | 'which individual') table:who_two_be_filter_table '?'
        | ('who' | 'which person' | 'which individual') table:who_two_have_filter_table '?'
        | ('who' | 'which person' | 'which individual') table:who_two_verb_filter_table '?'
        | ('who is the person' | 'who is the one' | 'who is the individual') table:who_with_filtered_table '?'
        | ('who is the person' | 'who is the one' | 'who is the individual') table:who_one_with_filter_table '?'
        | ('who is the person' | 'who is the one' | 'who is the individual') table:who_one_which_filter_table '?'
        | ('who is the person' | 'who is the one' | 'who is the individual') table:who_one_clean_filter_table '?'
        | ('who is the person' | 'who is the one' | 'who is the individual') table:who_two_with_filter_table '?'
        | ('who is the person' | 'who is the one' | 'who is the individual') table:who_two_which_filter_table '?'
        | ('who is the person' | 'who is the one' | 'who is the individual') table:who_two_clean_filter_table '?'
        | 'whose' table:whose_filtered_table '?'
    ) => new Ast.ExpressionStatement(null, table);
    ?turking (
          'who' table:who_verb_filtered_table '?'
        | 'who' table:who_one_be_filter_table '?'
        | 'who' table:who_one_have_filter_table '?'
        | 'who' table:who_one_verb_filter_table '?'
        | 'who' table:who_two_be_filter_table '?'
        | 'who' table:who_two_have_filter_table '?'
        | 'who' table:who_two_verb_filter_table '?'
        | 'whose' table:whose_filtered_table '?'
    ) => new Ast.ExpressionStatement(null, table);

    table:compute_question => new Ast.ExpressionStatement(null, table);
    table:where_question => new Ast.ExpressionStatement(null, table);
}

projection_question : Ast.ExpressionStatement = {
    ( 'what is' proj:projection_Any '?'
    | 'what is' proj:pair_projection '?' [weight=0.1]
    | 'who is' proj:projection_Entity__tt__username '?'
    | 'who is' proj:projection_Entity__tt__email_address '?'
    ) => {
        if (proj instanceof Ast.ProjectionExpression && proj.schema!.getArgType(proj.args[0]) instanceof Type.Array)
            return null;
        return C.sayProjection(proj);
    };
    ( 'what are' proj:projection_Any '?'
    | 'what are' proj:pair_projection '?' [weight=0.1]
    | 'who are' proj:projection_Entity__tt__username '?'
    | 'who are' proj:projection_Entity__tt__email_address '?'
    ) => {
        if (proj instanceof Ast.ProjectionExpression && !(proj.schema!.getArgType(proj.args[0]) instanceof Type.Array))
            return null;
        return C.sayProjection(proj);
    };
    ('what' | 'which') proj:verb_projection_Any '?' => C.sayProjection(proj);

    proj:question_projection_table '?' => C.sayProjection(proj);

    // now => get => say(...) (where questions)
    ?turking 'where is the' table:with_filtered_table =>
        C.sayProjection(C.makeSingleFieldProjection('table', Type.Location, table, 'geo'));
    !turking 'where' ('is' | 'are') ('' | 'the') table:with_filtered_table =>
        C.sayProjection(C.makeSingleFieldProjection('table', Type.Location, table, 'geo'));

    // boolean questions
    proj:boolean_projection '?' => C.sayProjection(proj);
}

explicit_when_condition : Ast.Expression = {
    ('if' | 'when') filter:if_filter 'in' table:complete_table with { is_monitorable = true } => {
        if (C.hasGetPredicate(filter.ast))
            return null;
        if (!table.schema!.is_monitorable)
            return null;
        if (_tpLoader.flags.turking && table.schema!.is_list)
            return null;
        const withFilter = C.addFilter(table, filter, { ifFilter: true });
        if (!withFilter)
            return null;
        return C.tableToStream(withFilter);
    };

    ('if' | 'when') filter:edge_filter 'in' table:complete_table with { is_monitorable = true } => {
        if (C.hasGetPredicate(filter.ast))
            return null;
        if (!table.schema!.is_monitorable || table.schema!.is_list)
            return null;
        const withFilter = C.addFilter(table, filter, { ifFilter: true });
        if (!withFilter)
            return null;
        return C.tableToStream(withFilter);
    };
}

when_command : Ast.ExpressionStatement = {
    // when => notify

    (
         'notify me' stream:stream
       | ('alert me' | 'inform me' | 'let me know' | 'i get notified' | 'i get alerted') stream:stream
       | 'send me' ('a message' | 'an alert' | 'a notification' | 'a pop up notification' | 'a popup notification') stream:stream
    ) => new Ast.ExpressionStatement(null, stream);

    !turking ('let me know' | 'notify me') ('of' | 'about') ('changes' | 'updates') 'in' proj:projection_Any with { is_monitorable = true } => {
        const stream = C.tableToStream(proj);
        if (!stream)
            return null;
        return new Ast.ExpressionStatement(null, stream);
    };
    !nofilter ('alert me' | 'tell me' | 'notify me' | 'let me know') stream:explicit_when_condition
        => new Ast.ExpressionStatement(null, stream);

    // when => get => notify
    !primonly complete_when_get_stream;

    // when => do
    !primonly complete_when_do_rule;

    // when => get => do
    ?triple_commands when_get_do_rule;
}

monitor_command : Ast.ExpressionStatement = {
    // when => notify

    ( ('monitor' | 'watch') table:with_filtered_table with { is_monitorable = true }
    | ('monitor' | 'watch') table:projection_Any with { is_monitorable = true }
    | ('let me know' | 'notify me') ('of' | 'about') ('changes' | 'updates') 'in' table:if_filtered_table with { is_monitorable = true }
    ) => {
        const stream = C.tableToStream(table);
        if (!stream)
            return null;
        return new Ast.ExpressionStatement(null, stream);
    };
    !nofilter {
        ( ('monitor' | 'watch') table:complete_table with { is_monitorable = true }
           'and' ('alert me' | 'notify me' | 'inform me' | 'warn me') ('if' | 'when') filter:if_filter with { functionName = table.functionName }
        | ('monitor' | 'watch') table:complete_table with { is_monitorable = true }
           'and' ('alert me' | 'notify me' | 'inform me' | 'warn me') ('if' | 'when') filter:if_filter with { functionName = null }
        ) => {
            if (C.hasGetPredicate(filter.ast))
                return null;
            if (table.schema!.is_list || !table.schema!.is_monitorable)
                return null;
            const withFilter = C.addFilter(table, filter);
            if (!withFilter)
                return null;
            const stream = C.tableToStream(withFilter);
            if (!stream)
                return null;
            return new Ast.ExpressionStatement(null, stream);
        };
    }
}

complete_action : Ast.ExpressionStatement = {
    action:thingpedia_action if complete
        => new Ast.ExpressionStatement(null, action);
    action:action_replace_param_with_table if complete
        => new Ast.ExpressionStatement(null, action);

    ( command:complete_action param:preposition_input_param with { functionName = command.functionName }
    | command:complete_action ('with' | 'having') param:npp_input_param with { functionName = command.functionName }
    ) => {
        const newAction = C.addActionInputParam(command.expression, param);
        if (newAction === null)
            return null;
        return new Ast.ExpressionStatement(null, newAction);
    };
}

say_command : Ast.ExpressionStatement = {}

if (_tpLoader.standardSchemas.say) {
    timer_rule : Ast.ExpressionStatement = {
        'send me a reminder' stream:timer
            => new Ast.ExpressionStatement(null, new Ast.ChainExpression(null, [stream, C.builtinSayAction()!], C.resolveChain(stream.schema!, _tpLoader.standardSchemas.say!)));
        'send me' ('a message' | 'an alert' | 'a notification' | 'a reminder' | 'a popup notification') stream:timer ('saying' | 'with the text') constant:constant_String
            => new Ast.ExpressionStatement(null, new Ast.ChainExpression(null, [stream, C.builtinSayAction(constant)!], C.resolveChain(stream.schema!, _tpLoader.standardSchemas.say!)));
    }

    when_command : Ast.ExpressionStatement = {
        !turking {
            (
                  'alert me' stream:stream ('saying' | 'with the text') constant:constant_String
                | 'show' ('the notification' | 'the message' | 'a popup notification that says' | 'a popup containing') constant:constant_String stream:stream
             ) => {
                const chain = new Ast.ChainExpression(null, [stream, C.builtinSayAction(constant)!], C.resolveChain(stream.schema!, _tpLoader.standardSchemas.say!));
                return new Ast.ExpressionStatement(null, chain);
            };
        }
    }

    say_command : Ast.ExpressionStatement = {
        (
              'say' c:constant_String
            | 'send me a message saying' c:constant_String
            | 'show a popup that says' c:constant_String
        ) => new Ast.ExpressionStatement(null, C.builtinSayAction(c)!);
    }
}
