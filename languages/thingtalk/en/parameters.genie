// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2019-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//         Silei Xu <silei@cs.stanford.edu>

import { Ast, Type } from 'thingtalk';

import * as C from '../ast_manip';

// import thingpedia info
import _tpLoader from '../load-thingpedia';

// these are autogenerated and depends on projection_*, which is also
// autogenerated
projection_Any : Ast.Expression = {}
verb_projection_Any : Ast.Expression = {}
stream_projection_Any : Ast.Expression = {}
table_join_replace_placeholder : Ast.ChainExpression = {}
action_replace_param_with_table : Ast.ChainExpression = {}
action_replace_param_with_stream : Ast.ChainExpression = {}

projection_Numeric : Ast.Expression = {
    projection_Number;
    projection_Currency;
    projection_Measure_ms;
    projection_Measure_byte;
    projection_Measure_kg;
    projection_Measure_C;
    projection_Measure_m;
    projection_Measure_m2;
    projection_Measure_m3;
    projection_Measure_mps;
    projection_Measure_Pa;
    projection_Measure_kcal;
}

single_projection_String : Ast.Expression = table:complete_table => C.makeEventTableProjection(table);

single_stream_projection_String : Ast.Expression = !nostream 'new' table:complete_table => C.makeEventStreamProjection(table);

single_projection_Entity__tt__picture : Ast.Expression = table:complete_table => {
    if (!table.schema!.out['picture_url'])
        return null;
    return new Ast.ProjectionExpression(null, table, ['picture_url'], [], [], table.schema);
};
single_stream_projection_Entity__tt__picture : Ast.Expression = !nostream 'new' table:complete_table => {
    if (!table.schema!.out['picture_url'])
        return null;
    if (!table.schema!.is_monitorable)
        return null;
    return new Ast.ProjectionExpression(null, new Ast.MonitorExpression(null, table, null, table.schema), ['picture_url'], [], [], table.schema);
};


the_out_param_Numeric : C.ParamSlot = {
    'the' p:out_param_Numeric => p;
    !inference {
        !turking {
            'its' p:out_param_Numeric => p;
            'their' p:out_param_Numeric => p;
        }
    }
}
the_out_param_Array__Any : C.ParamSlot = {
    'the' p:out_param_Array__Any => p;
    !inference {
        !turking {
            'its' p:out_param_Array__Any => p;
            'their' p:out_param_Array__Any => p;
        }
    }
}

the_out_param_pair : [C.ParamSlot, C.ParamSlot] = {
    'the' p1:out_param_Any 'and' p2:out_param_Any => {
        if (!C.isSameFunction(p1.schema, p2.schema))
            return null;
        if (p1.name === p2.name)
            return null;
        return [p1, p2];
    };
}

the_out_param_triple : [C.ParamSlot, C.ParamSlot, C.ParamSlot] = {
    'the' p1:out_param_Any ',' p2:out_param_Any (',' | '') 'and' p3:out_param_Any => {
        if (!C.isSameFunction(p1.schema, p2.schema) || !C.isSameFunction(p1.schema, p3.schema))
            return null;
        if (p1.name === p2.name || p1.name === p3.name || p2.name === p3.name)
            return null;
        return [p1, p2, p3];
    };
}

pair_projection : Ast.Expression = {
    ( ('both' | '') outParams:the_out_param_pair 'of' table:with_filtered_table
    | outParams:the_out_param_triple 'of the' table:with_arg_min_max_table
    ) => C.makeMultiFieldProjection('table', table, outParams);
}

where_question : Ast.Expression = {
    ( 'where is the' table:with_filtered_table
    | 'where is the' table:with_arg_min_max_table
    ) => C.makeSingleFieldProjection('table', Type.Location, table, 'geo');
}

boolean_projection : Ast.Expression = {
    'does' ('the' | '' | 'any') table:with_filtered_table 'have' p:npp_boolean_projection => C.makeSingleFieldProjection('table', Type.Boolean, table, p);
    'does' ('the' | '' | 'any') table:with_filtered_table p:avp_boolean_projection => C.makeSingleFieldProjection('table', Type.Boolean, table, p);
    'is' ('the' | '') table:with_filtered_table p:pvp_boolean_projection => C.makeSingleFieldProjection('table', Type.Boolean, table, p);
    'is' ('the' | '') table:with_filtered_table p:preposition_boolean_projection => C.makeSingleFieldProjection('table', Type.Boolean, table, p);
    'is' ('the' | '') table:with_filtered_table p:npi_boolean_projection => C.makeSingleFieldProjection('table', Type.Boolean, table, p);
    'is' ('the' | '') table:with_filtered_table p:npv_boolean_projection => C.makeSingleFieldProjection('table', Type.Boolean, table, p);
    'is' ('the' | '') table:with_filtered_table p:apv_boolean_projection => C.makeSingleFieldProjection('table', Type.Boolean, table, p);
}

for (const proj of _tpLoader.projections) {
    if (proj.category === 'pvp' || proj.category === 'preposition') {
        question_projection_table : Ast.Expression = #(proj.pronoun) #(proj.base) ('is'|'was'|'are'|'were') ('the' | '') table:with_filtered_table #(proj.canonical) =>
            C.makeSingleFieldProjection('table', null, table, proj.pslot);
        question_projection_table : Ast.Expression = #(proj.pronoun) #(proj.base) ('is'|'was'|'are'|'were') ('the' | '') table:with_arg_min_max_table #(proj.canonical) =>
            C.makeSingleFieldProjection('table', null, table, proj.pslot);

        if (proj.base) {
            command_projection_table : Ast.Expression = #(proj.base) ('that'|'which'|'') ('the' | '') table:with_filtered_table ('is'|'was'|'are'|'were') #(proj.canonical) =>
                C.makeSingleFieldProjection('table', null, table, proj.pslot);
            command_projection_table : Ast.Expression = #(proj.base) ('that'|'which'|'') ('the' | '') table:with_arg_min_max_table ('is'|'was'|'are'|'were') #(proj.canonical) =>
                C.makeSingleFieldProjection('table', null, table, proj.pslot);
        }
    }
    if (proj.category === 'avp') {
        question_projection_table : Ast.Expression = #(proj.pronoun) #(proj.base) ('do'|'does'|'did') ('the' | '') table:with_filtered_table #(proj.canonical) =>
            C.makeSingleFieldProjection('table', null, table, proj.pslot);
        question_projection_table : Ast.Expression = #(proj.pronoun) #(proj.base) ('do'|'does'|'did') ('the' | '') table:with_arg_min_max_table #(proj.canonical) =>
            C.makeSingleFieldProjection('table', null, table, proj.pslot);

        if (proj.base) {
            command_projection_table : Ast.Expression = #(proj.base) ('that'|'which'|'') ('the' | '') table:with_filtered_table #(proj.canonical) =>
                C.makeSingleFieldProjection('table', null, table, proj.pslot);
            command_projection_table : Ast.Expression = #(proj.base) ('that'|'which'|'') ('the' | '') table:with_arg_min_max_table #(proj.canonical) =>
                C.makeSingleFieldProjection('table', null, table, proj.pslot);
        }
    }
    if (proj.category === 'reverse_verb') {
        question_projection_table : Ast.Expression = #(proj.pronoun) #(proj.base) #(proj.canonical) ('the' | '') table:with_filtered_table  =>
            C.makeSingleFieldProjection('table', null, table, proj.pslot);
        question_projection_table : Ast.Expression = #(proj.pronoun) #(proj.base) #(proj.canonical) ('the' | '') table:with_arg_min_max_table  =>
            C.makeSingleFieldProjection('table', null, table, proj.pslot);

        if (proj.base) {
            command_projection_table : Ast.Expression = #(proj.base) ('that'|'which'|'') #(proj.canonical) ('the' | '') table:with_filtered_table =>
                C.makeSingleFieldProjection('table', null, table, proj.pslot);
            command_projection_table : Ast.Expression = #(proj.base) ('that'|'which'|'') #(proj.canonical) ('the' | '') table:with_arg_min_max_table =>
                C.makeSingleFieldProjection('table', null, table, proj.pslot);
        }
    }
}

for (let [typestr, type] of _tpLoader.types.all) {
    // don't access booleans or enums out arguments generically, as that rarely makes sense
    // (and when it does, you probably want a macro and maybe and edge trigger)
    if (!type.isEnum && !type.isBoolean) {
        $('the_out_param_' + typestr) = {
            'the' p:$('out_param_' + typestr) => p;

            /*!turking {
                'its' p:$('out_param_' + typestr) => p;
                'their' p:$('out_param_' + typestr) => p;
            }
            */
        }

        $('projection_' + typestr) : Ast.Expression = outParam:$('the_out_param_' + typestr) 'of' table:with_filtered_table =>
            C.makeSingleFieldProjection('table', type, table, outParam);
        $('projection_' + typestr) : Ast.Expression = outParam:$('the_out_param_' + typestr) 'of the' table:with_arg_min_max_table =>
            C.makeSingleFieldProjection('table', type, table, outParam);
        $('verb_projection_' + typestr) : Ast.Expression = outParam:$('out_param_' + typestr) ('do' | 'does') ('the' | '') table:with_filtered_table 'have' =>
            C.makeSingleFieldProjection('table', type, table, outParam);
        $('verb_projection_' + typestr) : Ast.Expression = outParam:$('out_param_' + typestr) ('do' | 'does') ('the' | '') table:with_arg_min_max_table 'have' =>
            C.makeSingleFieldProjection('table', type, table, outParam);
        $('stream_projection_' + typestr) : Ast.Expression = !nostream outParam:$('the_out_param_' + typestr) 'of new' table:with_filtered_table =>
            C.makeSingleFieldProjection('stream', type, table, outParam);
        $('stream_projection_' + typestr) : Ast.Expression = !nostream outParam:$('the_out_param_' + typestr) 'of the new' table:with_arg_min_max_table =>
            C.makeSingleFieldProjection('stream', type, table, outParam);

        projection_Any = $('projection_' + typestr);
        verb_projection_Any = $('verb_projection_' + typestr);

        if (typestr !== 'Entity__tt__picture' && typestr !== 'String') {
            $('single_projection_' + typestr) : Ast.Expression = table:with_filtered_table => C.makeTypeBasedTableProjection(table, type, typestr);

            $('single_stream_projection_' + typestr) : Ast.Expression = !nostream 'new' table:with_filtered_table =>
                C.makeTypeBasedStreamProjection(table, type, typestr);
        }
    }
}

placeholder_Number : Ast.UndefinedValue = {
    'some number' => new Ast.Value.Undefined(true);
    'some value' => new Ast.Value.Undefined(true);
}
placeholder_String : Ast.UndefinedValue = {
    'something' => new Ast.Value.Undefined(true);
}
placeholder_Currency : Ast.UndefinedValue = {
    'some value' => new Ast.Value.Undefined(true);
    'some amount' => new Ast.Value.Undefined(true);
}
placeholder_Time : Ast.UndefinedValue = {
    'some time' => new Ast.Value.Undefined(true);
     'a certain time' => new Ast.Value.Undefined(true);
}
placeholder_Date : Ast.UndefinedValue = {
    'some date' => new Ast.Value.Undefined(true);
    'a certain date' => new Ast.Value.Undefined(true);
    'some time' => new Ast.Value.Undefined(true);
    'a certain time' => new Ast.Value.Undefined(true);
}
placeholder_Location : Ast.UndefinedValue = {
    'some location' => new Ast.Value.Undefined(true);
    'a location' => new Ast.Value.Undefined(true);
    'some place' => new Ast.Value.Undefined(true);
    'a place' => new Ast.Value.Undefined(true);
    'a certain place' => new Ast.Value.Undefined(true);
    'somewhere' => new Ast.Value.Undefined(true);
}
placeholder_Measure_ms : Ast.UndefinedValue = {
    'some duration' => new Ast.Value.Undefined(true);
    'some amount of time' => new Ast.Value.Undefined(true);
}
placeholder_Measure_byte : Ast.UndefinedValue = {
    'some size' => new Ast.Value.Undefined(true);
    'a certain size' => new Ast.Value.Undefined(true);
}
placeholder_Measure_kg : Ast.UndefinedValue = {
    'a certain weight' => new Ast.Value.Undefined(true);
}
placeholder_Measure_C : Ast.UndefinedValue = {
    'a certain temperature' => new Ast.Value.Undefined(true);
}
placeholder_Measure_m : Ast.UndefinedValue = {
    'some distance' => new Ast.Value.Undefined(true);
    'some length' => new Ast.Value.Undefined(true);
}
placeholder_Measure_m2 : Ast.UndefinedValue = {
    'some size' => new Ast.Value.Undefined(true);
    'a certain size' => new Ast.Value.Undefined(true);
}
placeholder_Measure_m3 : Ast.UndefinedValue = {
    'some volume' => new Ast.Value.Undefined(true);
    'a certain volume' => new Ast.Value.Undefined(true);
}
placeholder_Measure_mps : Ast.UndefinedValue = {
    'some speed' => new Ast.Value.Undefined(true);
    'a certain speed' => new Ast.Value.Undefined(true);
}
placeholder_Entity__tt__picture : Ast.UndefinedValue = {
    'some image' => new Ast.Value.Undefined(true);
    'some picture' => new Ast.Value.Undefined(true);
    'some photo' => new Ast.Value.Undefined(true);
}
placeholder_Entity__tt__username : Ast.UndefinedValue = {
    'somebody' => new Ast.Value.Undefined(true);
    'someone' => new Ast.Value.Undefined(true);
    'some one' => new Ast.Value.Undefined(true);
    'some person' => new Ast.Value.Undefined(true);
}
placeholder_Entity__tt__phone_number : Ast.UndefinedValue = {
    'somebody' => new Ast.Value.Undefined(true);
    'someone' => new Ast.Value.Undefined(true);
    'some one' => new Ast.Value.Undefined(true);
    'some person' => new Ast.Value.Undefined(true);
    'some number' => new Ast.Value.Undefined(true);
    'some phone number' => new Ast.Value.Undefined(true);
}
placeholder_Entity__tt__email_address : Ast.UndefinedValue = {
    'somebody' => new Ast.Value.Undefined(true);
    'someone' => new Ast.Value.Undefined(true);
    'some one' => new Ast.Value.Undefined(true);
    'some person' => new Ast.Value.Undefined(true);
    'some email address' => new Ast.Value.Undefined(true);
}
placeholder_Entity__tt__path_name : Ast.UndefinedValue = {
    'some file' => new Ast.Value.Undefined(true);
    'some directory' => new Ast.Value.Undefined(true);
    'some folder' => new Ast.Value.Undefined(true);
}
placeholder_Entity__tt__url : Ast.UndefinedValue = {
    'some url' => new Ast.Value.Undefined(true);
    'some website' => new Ast.Value.Undefined(true);
    'some link' => new Ast.Value.Undefined(true);
}

for (let [pslot, typestr, pcanonical] of _tpLoader.params.in.values()) {
    if (typestr.startsWith('Enum__')) {
        // replace $-placeholders with "some X" where X is based on parameter name
        if (pslot.name !== 'power' && pslot.name !== 'state' && pslot.name !== 'p_power' && pslot.name !== 'p_state') {
            thingpedia_query : Ast.Expression = q:thingpedia_query #('a certain ' + pcanonical) [-> (pslot.name) { isUndefined: true }] =>
                C.replacePlaceholderWithUndefined(q, pslot, typestr);

            thingpedia_get_command : Ast.Expression = q:thingpedia_get_command #('a certain ' + pcanonical) [-> (pslot.name) { isUndefined: true }] =>
                C.replacePlaceholderWithUndefined(q, pslot, typestr);

            thingpedia_stream : Ast.Expression = s:thingpedia_stream #('a certain ' + pcanonical) [-> (pslot.name) { isUndefined: true }] =>
                C.replacePlaceholderWithUndefined(s, pslot, typestr);

            thingpedia_action : Ast.Expression = a:thingpedia_action #('a certain ' + pcanonical) [-> (pslot.name) { isUndefined: true }] =>
                C.replacePlaceholderWithUndefined(a, pslot, typestr);

            thingpedia_program : Ast.Expression = p:thingpedia_program #('a certain ' + pcanonical) [-> (pslot.name) { isUndefined: true }] =>
                C.replacePlaceholderWithUndefined(p, pslot, typestr);
        }
    }

    // don't parameter pass booleans or enums, as that rarely makes sense
    if (typestr !== 'Boolean' && !typestr.startsWith('Enum__')) {
        if (pslot.name !== 'count' && pslot.name !== 'p_count') {
            if (_tpLoader.flags.undefined_filter) {
                // replace $-placeholders with "some X" where X is based on parameter name
                thingpedia_query : Ast.Expression = q:thingpedia_query #('some ' + pcanonical) [-> (pslot.name) { isUndefined: true }] =>
                    C.replacePlaceholderWithUndefined(q, pslot, typestr);

                thingpedia_get_command : Ast.Expression = q:thingpedia_get_command #('some ' + pcanonical) [-> (pslot.name) { isUndefined: true }] =>
                    C.replacePlaceholderWithUndefined(q, pslot, typestr);

                thingpedia_stream : Ast.Expression = s:thingpedia_stream #('some ' + pcanonical) [-> (pslot.name) { isUndefined: true }] =>
                    C.replacePlaceholderWithUndefined(s, pslot, typestr);

                thingpedia_action : Ast.Expression = a:thingpedia_action #('some ' + pcanonical) [-> (pslot.name) { isUndefined: true }] =>
                    C.replacePlaceholderWithUndefined(a, pslot, typestr);

                thingpedia_program : Ast.Expression = p:thingpedia_program #('some ' + pcanonical) [-> (pslot.name) { isUndefined: true }] =>
                    C.replacePlaceholderWithUndefined(p, pslot, typestr);
            }
        }

        // replace $-placeholders with projection-based parameter passing

        // FIXME
        /*table_join_replace_placeholder : Ast.ChainExpression = {
            ( q:thingpedia_query p:with_filtered_table
            | q:thingpedia_query p:with_arg_min_max_table
            | q:thingpedia_query p:complete_table
            ) [-> pname] => C.actionReplaceParamWithTable(q, pname, p);
        }*/
        action_replace_param_with_table : Ast.ChainExpression = {
            ( a:thingpedia_action p:with_filtered_table
            | a:thingpedia_action p:with_arg_min_max_table
            | a:thingpedia_action p:complete_table
            ) [-> (pslot.name)] => C.actionReplaceParamWithTable(a, pslot, p);
        }
        action_replace_param_with_stream : Ast.ChainExpression = a:thingpedia_action p:$('single_stream_projection_' + typestr) [-> (pslot.name)]
            => C.actionReplaceParamWithStream(a, pslot, p);

        if (_tpLoader.types.id.has(typestr)) {
            forward_get_do_command : Ast.ChainExpression = command:forward_get_do_command ('it' | 'that' | 'them') [-> (pslot.name)] => {
                for (let joinArg in command.first.schema!.out) {
                    if (typestr === C.typeToStringSafe(command.first.schema!.out[joinArg]))
                        return C.addParameterPassing(command, pslot, new Ast.Value.VarRef(joinArg));
                }
                return null;
            };

            forward_when_do_rule : Ast.ChainExpression = rule:forward_when_do_rule ('it' | 'that' | 'them') [-> (pslot.name)] => {
                for (let joinArg in rule.first.schema!.out) {
                    if (typestr === C.typeToStringSafe(rule.first.schema!.out[joinArg]))
                        return C.addParameterPassing(rule, pslot, new Ast.Value.VarRef(joinArg));
                }
                return null;
            };

            when_get_stream : Ast.ChainExpression = stream:when_get_stream ('it' | 'that' | 'them') [-> (pslot.name)] => {
                for (let joinArg in stream.first.schema!.out) {
                    if (typestr === C.typeToStringSafe(stream.first.schema!.out[joinArg]))
                        return C.addParameterPassing(stream, pslot, new Ast.Value.VarRef(joinArg));
                }
                return null;
            };
        } else {
            // FIXME
            //table_join_replace_placeholder : Ast.ChainExpression = q:thingpedia_query p:$('projection_' + typestr) [-> pname]
            //    => C.actionReplaceParamWithTable(q, pname, p);
            action_replace_param_with_table : Ast.ChainExpression = a:thingpedia_action p:$('projection_' + typestr) [-> (pslot.name)]
                => C.actionReplaceParamWithTable(a, pslot, p);
            action_replace_param_with_stream : Ast.ChainExpression = a:thingpedia_action p:$('stream_projection_' + typestr) [-> (pslot.name)]
                => C.actionReplaceParamWithStream(a, pslot, p);

            forward_get_do_command : Ast.ChainExpression = !turking command:forward_get_do_command p:$('the_out_param_' + typestr) [-> (pslot.name)]
                => C.addParameterPassing(command, pslot, p.ast);
            backward_get_do_command : Ast.ChainExpression = !turking command:backward_get_do_command p:$('the_out_param_' + typestr) [-> (pslot.name)]
                => C.addParameterPassing(command, pslot, p.ast);
            forward_when_do_rule : Ast.ChainExpression = !turking rule:forward_when_do_rule p:$('the_out_param_' + typestr) [-> (pslot.name)]
                => C.addParameterPassing(rule, pslot, p.ast);
            backward_when_do_rule : Ast.ChainExpression = !turking rule:backward_when_do_rule p:$('the_out_param_' + typestr) [-> (pslot.name)]
                => C.addParameterPassing(rule, pslot, p.ast);
            when_get_stream : Ast.ChainExpression = !turking stream:when_get_stream p:$('the_out_param_' + typestr) [-> (pslot.name)]
                => C.addParameterPassing(stream, pslot, p.ast);
        }

        if (pslot.name === 'p_picture_url') {
            forward_get_do_command : Ast.ChainExpression = command:forward_get_do_command ('it' | 'that' | 'them') [-> (pslot.name)]
                => C.addParameterPassing(command, pslot, new Ast.Value.VarRef('picture_url'));
            forward_when_do_rule : Ast.ChainExpression = rule:forward_when_do_rule ('it' | 'that' | 'them') [-> (pslot.name)]
                => C.addParameterPassing(rule, pslot, new Ast.Value.VarRef('picture_url'));
            when_get_stream : Ast.ChainExpression = stream:when_get_stream ('it' | 'that' | 'them') [-> (pslot.name)]
                => C.addParameterPassing(stream, pslot, new Ast.Value.VarRef('picture_url'));
        }

        if (typestr === 'String' && ['p_body', 'p_message', 'p_caption', 'p_status', 'p_text'].indexOf(pslot.name) >= 0) {
            forward_get_do_command : Ast.ChainExpression = command:forward_get_do_command ('it' | 'that' | 'them') [-> (pslot.name)] => {
                for (let pname in command.first.schema!.out) {
                    if (pname === 'picture_url')
                        return null;
                    let ptype = command.first.schema!.out[pname];
                    if (_tpLoader.types.id.has(C.typeToStringSafe(ptype)))
                        return null;
                }
                return C.addParameterPassing(command, pslot, new Ast.Value.Event(null));
            };

            forward_when_do_rule : Ast.ChainExpression = rule:forward_when_do_rule ('it' | 'that' | 'them') [-> (pslot.name)] => {
                for (let pname in rule.first.schema!.out) {
                    if (pname === 'picture_url')
                        return null;
                    let ptype = rule.first.schema!.out[pname];
                    if (_tpLoader.types.id.has(C.typeToStringSafe(ptype)))
                        return null;
                }
                return C.addParameterPassing(rule, pslot, new Ast.Value.Event(null));
            };

            when_get_stream : Ast.ChainExpression = stream:when_get_stream ('it' | 'that' | 'them') [-> (pslot.name)] => {
                for (let pname in stream.first.schema!.out) {
                    if (pname === 'picture_url')
                        return null;
                    let ptype = stream.first.schema!.out[pname];
                    if (_tpLoader.types.id.has(C.typeToStringSafe(ptype)))
                        return null;
                }
                return C.addParameterPassing(stream, pslot, new Ast.Value.Event(null));
            };
        }
    }
}
