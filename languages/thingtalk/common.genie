// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2019-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>

import { Ast, Type } from 'thingtalk';

// import the combinator library
import * as C from './ast_manip';
import _tpLoader from './load-thingpedia';

import { SlotBag } from './slot_bag';

import './common-constants.genie';

// Declare key functions for non-contextual stuff
keyfn = {
    C.Placeholder : C.placeholderKeyFn,
    Ast.Value : C.valueKeyFn,
    Ast.LocationValue : C.valueKeyFn,
    Ast.NumberValue : C.numberValueKeyFn,
    Ast.EntityValue : C.entityValueKeyFn,
    Ast.ContextRefValue : C.valueKeyFn,
    [Ast.Value, Ast.Value] : C.valueArrayKeyFn,
    Ast.Value[] : C.valueArrayKeyFn,
    Ast.Expression : C.expressionKeyFn,
    Ast.InvocationExpression : C.expressionKeyFn,
    Ast.Invocation : C.invocationKeyFn,
    Ast.ExpressionStatement : C.expressionStatementKeyFn,
    Ast.FunctionDef : C.functionDefKeyFn,
    C.InputParamSlot : C.inputParamKeyFn,
    C.FilterSlot : C.filterKeyFn,
    C.FilterSlot|C.DomainIndependentFilterSlot : C.filterKeyFn,
    C.ParamSlot : C.paramKeyFn,
    C.ParamSlot[] : C.paramArrayKeyFn,
    C.ArgMinMax : C.argMinMaxKeyFn,
    SlotBag : C.slotBagKeyFn,
    C.ErrorMessage : C.errorMessageKeyFn,
}

// Thingpedia Grammar Rules

// the following are a all autogenerated by load-thingpedia.js

thingpedia_query : Ast.Expression = {}
thingpedia_get_command : Ast.Expression = {}
thingpedia_stream : Ast.Expression = {}
thingpedia_action : Ast.Expression = {}
thingpedia_program : Ast.Expression = {}
thingpedia_who_question : Ast.Expression = {}

thingpedia_search_question : C.ParamSlot = {}
thingpedia_slot_fill_question : C.ParamSlot = {}
thingpedia_user_question : C.ParamSlot[] = {}

thingpedia_result : SlotBag = {}
thingpedia_action_past : Ast.Expression = {}
thingpedia_error_message : C.ErrorMessage = {}

coref_constant : Ast.Value = {}
placeholder : C.Placeholder = {}

out_param_Any : C.ParamSlot = {}
out_param_Array__Any : C.ParamSlot = {}
out_param_Array__Compound : C.ParamSlot = {}
out_param_ArrayCount : C.ParamSlot = {}
out_param_npp : C.ParamSlot = {}
out_param_npi : C.ParamSlot = {}
out_param_avp : C.ParamSlot = {}
out_param_pvp : C.ParamSlot = {}
out_param_npv : C.ParamSlot = {}
out_param_apv : C.ParamSlot = {}

input_param : C.ParamSlot = {}

// helper prefix for "and" filters
// English overrides this to add "both" as well
both_prefix : string = {
    '';
}

// filters & input parameters on npp parameters
// nnp: Noun-Phrase parameter for Property of the subject
// e.g.: "name", "date of birth"

npp_filter : C.FilterSlot = {}
npp_input_param : C.InputParamSlot = {}
npp_argminmax : C.ArgMinMax = {}
coref_npp_filter : C.FilterSlot = {}
coref_npp_input_param : C.InputParamSlot = {}
npp_boolean_projection : C.ParamSlot = {}

// filters & input parameters on npi parameters
// npi: Noun-phrase parameter for Identity of the subejct
// e.g.: "owner of <company>", "student in <university>"
npi_filter : C.FilterSlot = {}
npi_input_param : C.InputParamSlot = {}
npi_argminmax : C.ArgMinMax = {}
coref_npi_filter : C.FilterSlot = {}
coref_npi_input_param : C.InputParamSlot = {}
npi_boolean_projection : C.ParamSlot = {}

// filters & input parameters on pvp parameters
// pvp: Passive-Verb Phrase parameter
// e.g.: "called <nickname>", "born on <date>"
pvp_filter : C.FilterSlot = {}
pvp_input_param : C.InputParamSlot = {}
pvp_argminmax : C.ArgMinMax = {}
coref_pvp_filter : C.FilterSlot = {}
coref_pvp_input_param : C.InputParamSlot = {}
pvp_boolean_projection : C.ParamSlot = {}

// filters & input parameters on prep parameters
// prep: preposition parameter
// e.g.: "at <time>", "in <area>"
preposition_filter : C.FilterSlot = {}
preposition_input_param : C.InputParamSlot = {}
preposition_argminmax : C.ArgMinMax = {}
coref_preposition_filter : C.FilterSlot = {}
coref_preposition_input_param : C.InputParamSlot = {}
preposition_boolean_projection : C.ParamSlot = {}

// filters & input parameters on avp parameters
// avp: Active-Verb Phrase parameter
// e.g.: "owns <company>", "studied in <university>"
avp_filter : C.FilterSlot = {}
avp_input_param : C.InputParamSlot = {}
avp_argminmax : C.ArgMinMax = {}
coref_avp_filter : C.FilterSlot = {}
coref_avp_input_param : C.InputParamSlot = {}
avp_boolean_projection : C.ParamSlot = {}

// filters & input parameters on npv parameters
// npv: implicit parameter with Noun-Phrase Value, i.e., the parameter itself will not appear in the sentence
// e.g.: "Bob is a PhD", the parameter `academic_degree` is implicit, and should be inferred by the value "PhD"
npv_filter : C.FilterSlot = {}
npv_input_param : C.InputParamSlot = {}
npv_argminmax : C.ArgMinMax = {}
coref_npv_filter : C.FilterSlot = {}
coref_npv_input_param : C.InputParamSlot = {}
npv_boolean_projection : C.ParamSlot = {}

// filters & input parameters on apv parameter
// apv: implicit parameter with Adjective-Phrase Value (similar to npv, but in adjective form)
// e.g.: "Bob is left-handed"
apv_filter : C.FilterSlot = {}
apv_input_param : C.InputParamSlot = {}
apv_argminmax : C.ArgMinMax = {}
coref_apv_filter : C.FilterSlot = {}
coref_apv_input_param : C.InputParamSlot = {}
apv_boolean_projection : C.ParamSlot = {}

// filters & input parameters on reverese_verb parameter
// reverse verb: verb-phrase parameter where value is the subject of the verb phrase
// e.g., "movies that Bob directed"
reverse_verb_filter : C.FilterSlot = {}
reverse_verb_input_param : C.InputParamSlot = {}
coref_reverse_verb_filter : C.FilterSlot = {}
coref_reverse_verb_input_param : C.InputParamSlot = {}

// projections
question_projection_table = {}
command_projection_table = {}


constant_name : Ast.EntityValue = {}

base_table : Ast.InvocationExpression = {}
base_noun_phrase : Ast.FunctionDef = {}
generic_anything_noun_phrase : Ast.InvocationExpression = {}
generic_base_noun_phrase : Ast.InvocationExpression = {}

{
await _tpLoader.init($runtime, $grammar, $locale, $options);
}

// empty defaults for certain parameter types in case we don't have devices with
// those parameters
projection_Entity__tt__username : Ast.Expression = {}
projection_Entity__tt__email_address : Ast.Expression = {}

for (const [pslot,] of _tpLoader.params.in.values()) {
    thingpedia_stream : Ast.Expression = {
        s:thingpedia_stream v:constant_Any with { type = (pslot.type) } [-> (pslot.name) { isConstant: true }] => C.replacePlaceholderWithConstant(s, pslot, v);
    }

    thingpedia_query : Ast.Expression = {
        q:thingpedia_query v:constant_Any with { type = (pslot.type) } [-> (pslot.name) { isConstant: true }] => C.replacePlaceholderWithConstant(q, pslot, v);
    }

    thingpedia_get_command : Ast.Expression = {
        q:thingpedia_get_command v:constant_Any with { type = (pslot.type) } [-> (pslot.name) { isConstant: true }] => C.replacePlaceholderWithConstant(q, pslot, v);
    }

    thingpedia_action : Ast.Expression = {
        a:thingpedia_action v:constant_Any with { type = (pslot.type) } [-> (pslot.name) { isConstant: true }] => C.replacePlaceholderWithConstant(a, pslot, v);
    }

    thingpedia_action_past : Ast.Expression = {
        a:thingpedia_action_past v:constant_Any with { type = (pslot.type) } [-> (pslot.name) { isConstant: true }] [priority=0.5] => C.replacePlaceholderWithConstant(a, pslot, v);
    }

    thingpedia_error_message : C.ErrorMessage = {
        msg:thingpedia_error_message v:constant_Any with { type = (pslot.type) } [-> (pslot.name) { isConstant: true }] [priority=0.5] => C.replaceErrorMessagePlaceholder(msg, pslot, v);
    }

    thingpedia_program : Ast.Expression = {
        p:thingpedia_program v:constant_Any with { type = (pslot.type) } [-> (pslot.name) { isConstant: true }] => C.replacePlaceholderWithConstant(p, pslot, v);
    }

    // don't use placeholders for booleans or enums, as that rarely makes sense
    if (pslot.type !== Type.Boolean && !pslot.type.isEnum) {
        if (pslot.name !== 'count' && pslot.name !== 'p_count') {
            if ($options.flags.undefined_filter) {
                // replace $-placeholders with "some X" where X is based on parameter type
                thingpedia_query : Ast.Expression = q:thingpedia_query placeholder with { type = (pslot.type) } [-> (pslot.name) { isUndefined: true }] =>
                    C.replacePlaceholderWithUndefined(q, pslot);

                thingpedia_get_command : Ast.Expression = q:thingpedia_get_command placeholder with { type = (pslot.type) } [-> (pslot.name) { isUndefined: true }] =>
                    C.replacePlaceholderWithUndefined(q, pslot);

                thingpedia_stream : Ast.Expression = s:thingpedia_stream placeholder with { type = (pslot.type) } [-> (pslot.name) { isUndefined: true }] =>
                    C.replacePlaceholderWithUndefined(s, pslot);

                thingpedia_action : Ast.Expression = a:thingpedia_action placeholder with { type = (pslot.type) } [-> (pslot.name) { isUndefined: true }] =>
                    C.replacePlaceholderWithUndefined(a, pslot);

                thingpedia_program : Ast.Expression = p:thingpedia_program placeholder with { type = (pslot.type) } [-> (pslot.name) { isUndefined: true }] =>
                    C.replacePlaceholderWithUndefined(p, pslot);
            }
        }
    }
}

for (const pslot of _tpLoader.params.all) {
    thingpedia_result : SlotBag = {
        bag:thingpedia_result v:constant_Any with { type = (pslot.type) } [-> (pslot.name) { isConstant: true }] [priority=0.1] => C.replaceSlotBagPlaceholder(bag, pslot, v);
    }
}
